# Form
- Form은 사용자가 요청하여 전달된 데이터를 검증/가공하는데 특화된 기능이다.
- View 함수가 지나치게 방대해지는 것을 막는다.
- 사용자가 전달한 데이터를 처리할 때는 가급적 Form을 사용하는 것이 좋다.
## Form 인스턴스 생성 시 data를 인수로 갖는 경우
- data 인수를 채운 채로 생성된 Form은 해당 data의 유효성을 검증하기 위해 사용된다.
- data 없이 생성된 Form은 Template에 form 정보를 전달하기 위해 사용된다.

## Form 클래스로 데이터를 받은 이후
- 반드시 `is_valid`를 호출해야 한다.
- `is_valid`를 실행하기 전에는 form의 cleaned_data에 접근 불가능하다.

## 유효성 검사
- `views.py`의 `is_valid`로 form에 대한 유효성 검사를 마쳤는데, 다시 `views.py`에서 추가적인 유효성 검사 로직이 실행된다. (비밀번호 일치 여부, 사용자 중복 여부 등의 함수 로직)
- 입력값의 모든 유효성 검사를 Form 내부에서 실행할 수 있도록 로직을 수정하면 `views.py`에서는 검증된 데이터만을 사용하기 때문에 코드를 더욱 깔끔하게 사용할 수 있다.
- `clean_<fieldname>`, `clean` 메소드를 정의(deF)하여 유효성을 검증할 수 있다.
- 다른 모델의 필드를 불러와서 검증할 수도 있다.

# Authenticate
- `authenticate` 함수는 주어진 값에 해당하는 사용자가 있는지 판단한다.
- 해당하는 사용자가 있다면 User 인스턴스가 반환되며, 없다면 반환되지 않는다.
- 단순히 입력한 username/password에 해당하는 사용자가 있는지 검사하고 User 객체를 돌려주는 역할을 한다.
- `authenticate` 함수 호출 시 입력한 password 문자열은 변형 과정을 거친 후 DB의 내용과 비교하게 된다.

# Login
- 브라우저에 해당 사용자를 유지시켜준다.
- 웹 사이트에 로그인하는 경우, 로그인 상태로 변환 및 유지시켜준다.
- `login` 함수 호출에는 현재 요청(`request`) 객체와 사용자(`User`) 객체가 필요하다.


# Logout
- 장고에서는 기본적으로 `GET`, `POST` 요청에 관계없이 로그아웃이 동작한다.
- `POST` 요청에서만 동작하게 하고 싶다면 `request.method`에 따라 동작을 다르게 변형하여 사용할 수 있다.


# create_user()
- `create_user()` 메서드를 사용하여, user을 만들 시 비밀번호를 변형해서 DB에 저장할 수 있다.
  - 사용자가 입력한 비밀번호를 암호화하지 않고 DB에 저장하는 것은 보안상 매우 좋지 않으며, 대한민국 개인정보 보호법 위반사항이다.
- 입력한 비밀번호를 변형하는 것을 해시화(Hashing)이라고 부른다. 해시 알고리즘은 임의의 길이 데이터를 고정 길이의 데이터로 변형하는 함수로, 해시함수로 만든 값은 복원이 불가능하다.


# ORM 
- Django ORM에서는 외래 키 필드(FK)가 참조하는 모델의 인스턴스를 필요로 한다.
  - ex. Survey(), User() 등
- 즉 외래 키에 직점 id 값을 할당하는게 아니라, 참조하는 모델의 객체 자체를 할당해야 한다.
- 외래 키 필드가 모델 인스턴스를 필요로 함으로써, 일관성 유지, 자동 검증, 역참조 등의 ORM 기능 지원이 가능해진다.
## objects.get()
- `get()`은 쿼리에 맞는 객체 하나(0번째)만 반환한다.
- `get()`은 `filter.first()`와 같다.
- 쿼리에 맞는 객체가 없을 시 DoesNotExist 에러가 발생한다.
- 객체를 반환하기 때문에 `.속성`를 사용해서 객체가 가진 속성값에 접근할 수 있다.
- 객체를 반환하기 때문에 query 속성에 접근할 수 없다.
## objects.filter()
- `filter()`은 조건에 맞는 객체 여러개를 묶어 쿼리셋 형태로 반환한다.
- 조건에 맞는 객체가 없을 시 에러가 아닌 빈 쿼리셋을 반환한다.
- 쿼리셋이기 때문에 query 속성에 접근할 수 있다.